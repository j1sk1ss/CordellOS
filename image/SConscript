import os
import re
import time

from decimal import Decimal
from io import SEEK_CUR, SEEK_SET
from pathlib import Path
from shutil import copy2

import parted
import sh
import math

from elftools.elf.elffile import ELFFile
from elftools.elf.descriptions import describe_p_type

from SCons.Action import Action
from SCons.Builder import Builder
from SCons.Environment import Environment

from build_scripts.utility import glob_recursive

Import('fst_stg')
Import('sec_stg')
Import('kernel')

Import('TARGET_ENVIRONMENT')
TARGET_ENVIRONMENT: Environment
env:Environment = TARGET_ENVIRONMENT

SECTOR_SIZE = 512

def generate_image_file(target: str, size_sectors: int):
    with open(target, 'wb') as fout:
        fout.write(bytes(size_sectors * SECTOR_SIZE))
        fout.close()

def create_filesystem(target: str, filesystem, reserved_sectors=0, offset=0):
    if filesystem in ['fat12', 'fat16', 'fat32']:
        reserved_sectors += 1
        if filesystem == 'fat32':
            reserved_sectors += 1

        mkfs_fat = sh.Command('mkfs.fat')
        mkfs_fat(target,
                 F=filesystem[3:],              # fat size
                 n='CLOS',                      # label
                 R=reserved_sectors,            # reserved sectors
                 offset=offset
        )
    elif filesystem == 'ext2':
        mkfs_ext2 = sh.Command('mkfs.ext2')
        mkfs_ext2(target,
                  L='CLOS',                     # label
                  E=f'offset={offset * SECTOR_SIZE}'
        )
    else:
        raise ValueError('Unsupported filesystem ' + filesystem)


def find_symbol_in_map_file(map_file: str, symbol: str):
    with map_file.open('r') as fmap:
        for line in fmap:
            if symbol in line:
                match = re.search('0x([0-9a-fA-F]+)', line)
                if match is not None:
                    return int(match.group(1), base=16)
                
    return None

                                                # FINDING THE SECOND STAGE

                        #####################################################################
                        ##                      ##                          ##
                        ##  JMP INSTRUCTION     ##  FILE SYSTEM HEADERS     ##  ENTRY POINT
                        ##                      ##                          ##                  *AA55*
                        #############################################################################
                                                    #|
                                                    #|
                                                    # sector num -> lenght

def install_fst_stg(target: str, fst_stg: str, boot_data_lba, offset=0):

    """
    Installs fst_stg to the given disk/partition.

    fst_stg.bin is expected to have a fst_stg.map file accompanying it, generated by the linker.
    The install process goes like this:
      - the 'phys' and '__entry_start' symbols are read from .map file
      - by subtracting phys, we can obtain the offset of the __entry_start symbol in the .bin file
      - write the first 3 bytes, representing the jump instruction
      - skip over the headers, we keep the ones provided by the format command
      - write starting from __entry_start

        Parameters:
            target (str): Path to image file
            fst_stg (str): Path to fst_stg.bin file
            offset (int): Offset where partition begins

    """

    # find fst_stg map file
    map_file = Path(fst_stg).with_suffix('.map')
    if not map_file.exists():
        raise ValueError("Can't find " + map_file)
    
    phys = find_symbol_in_map_file(map_file, 'phys')
    if phys is None:
        raise ValueError("Can't find phys symbol in map file " + str(map_file))

    entry_offset = find_symbol_in_map_file(map_file, '__entry_start')
    if entry_offset is None:
        raise ValueError("Can't find __entry_start symbol in map file " + str(map_file))
    entry_offset -= phys

    boot_table_lba = find_symbol_in_map_file(map_file, 'boot_table_lba')
    if boot_table_lba is None:
        raise ValueError("Can't find boot_table_lba symbol in map file " + str(map_file))
    boot_table_lba -= phys

    with open(fst_stg, 'rb') as ffst_stg:
        with os.fdopen(os.open(target, os.O_WRONLY | os.O_CREAT), 'wb+') as ftarget:
            ftarget.seek(offset * SECTOR_SIZE, SEEK_SET)

            # write first 3 bytes jump instruction
            ftarget.write(ffst_stg.read(3))

            # write starting at entry_offset (end of header)
            ffst_stg.seek(entry_offset - 3, SEEK_CUR)
            ftarget.seek(entry_offset - 3, SEEK_CUR)
            ftarget.write(ffst_stg.read())

            # write location of sec_stg
            ftarget.seek(offset * SECTOR_SIZE + boot_table_lba, SEEK_SET)
            ftarget.write(boot_data_lba.to_bytes(4, byteorder='little'))


def addr_to_seg_offset(addr: int):
    seg = (addr & 0xFFFF0000) >> 4
    off = (addr & 0x0000FFFF)
    return (seg << 16) | off


def install_sec_stg(target: str, sec_stg: str, boot_data_lba=0, offset=0, limit=None):

    """
    Installs sec_stg to the given disk/partition.

    sec_stg is expected to be an ELF file. The install process goes like this:
      - the ELF file is parsed
      - write the "program" to disk
      - save the entry point to the boot table
      - put the details on how to read the "program" to the boot table

        Parameters:
            target (str): Path to image file
            fst_stg (str): Path to fst_stg.bin file
            offset (int): Offset where to store sec_stg

    """

    with open(sec_stg, 'rb') as fsec_stg:
         with os.fdopen(os.open(target, os.O_WRONLY | os.O_CREAT), 'wb+') as ftarget:
            sec_stg_elf = ELFFile(fsec_stg)

            entry_point = addr_to_seg_offset(sec_stg_elf['e_entry'])
            boot_table = []

            current_lba = offset

            for segment in sec_stg_elf.iter_segments():
                if describe_p_type(segment['p_type']) == 'LOAD':
                    data = segment.data()
                    len_sectors = math.ceil(len(data) / SECTOR_SIZE)

                    # add to boot_table
                    boot_table.append({
                        'lba': current_lba,
                        'load_addr': addr_to_seg_offset(segment['p_vaddr']),
                        'count': len_sectors
                    })

                    # write data
                    ftarget.seek(current_lba * SECTOR_SIZE, SEEK_SET)
                    ftarget.write(data)
                    current_lba += len_sectors

                    if current_lba >= limit:
                        raise Exception("Stage 2 is too big!!! It is overwriting partition 1.")
            
            # add null table entry
            boot_table.append({
                'lba': 0,
                'load_addr': 0,
                'count': 0
            })

            # write boot data
            ftarget.seek(boot_data_lba * SECTOR_SIZE, SEEK_SET)
            ftarget.write(entry_point.to_bytes(4, byteorder='little'))

            for entry in boot_table:
                ftarget.write(entry['lba'].to_bytes(4, byteorder='little'))
                ftarget.write(entry['load_addr'].to_bytes(4, byteorder='little'))
                ftarget.write(entry['count'].to_bytes(2, byteorder='little'))

                                            # FLOPPY IMAGE CREATION

                                ################################################
                                ##               ##                ##
                                ##  FIRST_STAGE  ##  SECOND_STAGE  ##   REST OS STUFF
                                ##               ##   *reserved*   ##
                                ##########################################################

                                            # FLOPPY IMAGE CREATION


def build_floppy(image, fst_stg, sec_stg, kernel, files, env):
    size_sectors = 2880
    sec_stg_size = os.stat(sec_stg).st_size
    sec_stg_sectors = (sec_stg_size + SECTOR_SIZE - 1) // SECTOR_SIZE
    
    generate_image_file(image, size_sectors)

    print(f"> formatting file using fat12...")
    create_filesystem(image, 'fat12', reserved_sectors=sec_stg_sectors+1)

    print(f"> installing fst_stg...")
    install_fst_stg(image, fst_stg, boot_data_lba=1)

    print(f"> installing sec_stg...")
    install_sec_stg(image, sec_stg, boot_data_lba=1, offset=2)

    print(f"> copying files...")
    print('    ... copying', kernel)
    sh.mmd('-i', image, "::boot")
    sh.mcopy('-i', image, kernel, "::boot/")

    # copy rest of files
    src_root = env['BASEDIR']
    for file in files:
        file_src = file.srcnode().path
        file_rel = os.path.relpath(file_src, src_root)
        file_dst = '::' + file_rel

        if os.path.isdir(file_src):
            print('    ... creating directory', file_rel)
            sh.mmd('-i', image, file_dst)
        else:
            print('    ... copying', file_rel)
            sh.mcopy('-i', image, file_src, file_dst)


def create_partition_table(target: str, align_start: int):
    device  = parted.getDevice(target)
    disk    = parted.freshDisk(device, 'msdos')

    freeSpace = disk.getFreeSpaceRegions()

    partitionGeometry   = parted.Geometry(device, align_start, end=freeSpace[-1].end)
    partition           = parted.Partition(disk=disk, type=parted.PARTITION_NORMAL, geometry=partitionGeometry)

    partition.setFlag(parted.PARTITION_BOOT)

    disk.addPartition(partition, constraint=device.optimalAlignedConstraint)
    disk.commit()


def mount_fs(image: str, mount_dir: str):
    sh.guestmount(mount_dir, add=image, mount='/dev/sda1')

def unmount_fs(mount_dir: str):
    time.sleep(3)
    sh.fusermount(u=mount_dir)

                                                    # DISK IMAGE CREATION

                ################################################        (...)   #########################
                ##                            |##                       (...)   ##                 |
                ##  MBR (Master Boot Sector)  |##   SECOND_STAGE        (...)   ##   FIRST_STAGE   |    PARTITION (1)
                ##         *partition table*->|##                       (...)   ##                 |
                ####################################################    (...)   ##########################################

                                                    # DISK IMAGE CREATION

def build_disk(image, fst_stg, sec_stg, kernel, files, env):
    size_sectors        = (env['image_size'] + SECTOR_SIZE - 1) // SECTOR_SIZE
    file_system         = env['image_file_system']
    partition_offset    = 2048

    generate_image_file(image, size_sectors)

    # create partition table
    print(f"> creating partition table...")
    create_partition_table(image, partition_offset)

    # create file system
    print(f"> formatting file using {file_system}...")
    create_filesystem(image, file_system, offset=partition_offset)

    # install fst_stg
    print(f"> installing fst_stg...")
    # install_fst_stg(image, fst_stg, offset=partition_offset, boot_data_lba=1)
 
    # install sec_stg
    print(f"> installing sec_stg...")
    # install_sec_stg(image, sec_stg, offset=2, boot_data_lba=1, limit=partition_offset)

    tempdir_name = 'tmp_mount_{0}'.format(int(time.time()))
    tempdir = os.path.join(os.path.dirname(image), tempdir_name)
    try:
        # mount
        os.mkdir(tempdir)

        print(f"> mounting image to {tempdir}...")
        mount_fs(image, tempdir)

        # copy kernel
        print(f"> copying kernel...")
        bootdir = os.path.join(tempdir, 'boot')
        os.makedirs(bootdir)
        copy2(kernel, bootdir)

        # copy rest of files
        src_root = env['BASEDIR']
        print(f"> copying files...")
        for file in files:
            file_src = file.srcnode().path
            file_rel = os.path.relpath(file_src, src_root)
            file_dst = os.path.join(tempdir, file_rel)

            if os.path.isdir(file_src):
                print('    ... creating directory', file_rel)
                os.makedirs(file_dst)
            else:
                print('    ... copying', file_rel)
                copy2(file_src, file_dst)

    finally:
        print("> cleaning up...")
        try:
            unmount_fs(tempdir)
        except:
            pass
        os.rmdir(tempdir)


def build_image(target, source, env):
    fst_stg = str(source[0])
    sec_stg = str(source[1])
    kernel  = str(source[2])
    files   = source[3:]

    image = str(target[0])
    if env['image_type'] == 'floppy':
        build_floppy(image, fst_stg, sec_stg, kernel, files, env)
    elif env['image_type'] == 'disk':
        build_disk(image, fst_stg, sec_stg, kernel, files, env)
    else:
        raise ValueError('Unknown image type ' + env['image_type'])


# Setup image target
root = env.Dir('root')
root_content = glob_recursive(env, '*', root)
inputs = [fst_stg, sec_stg, kernel] + root_content

output_fmt = 'img'
# if env['image_type'] == 'qcow3':
#     output_fmt = 'qcow3'

output = f'os_image.{output_fmt}'

image = env.Command(output, inputs,
                    action=Action(build_image, 'Creating disk image...'), 
                    BASEDIR=root.srcnode().path)
env.Depends(image, inputs)

Export('image')